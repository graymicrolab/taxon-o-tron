# taxon-o-tron
version = "1"
updated = "September 16, 2022"

"""
The taxon-o-tron is a tool for determining the taxonomic distribution of
protein homologs within a given clade of organisms. It is intended for use
in concert with BLASTer.py, and generates taxonomic trees rather than
alignments.

Based heavily on code in script BLASTer.py version 4.2.

Python 3.10.7
Biopython 1.79
treemaker 1.4

Setup (saved to file; adjustable if needed):
    Inputs:
        Entrez email
        save path

Step 1: Initial Inputs
    Inputs:
        protein name
        protein sequence (full or partial)

Step 2: Identifying the Target Clade
    Inputs:
        target clade (with test if it's legitimate)
    Outputs:
        number of species in target clade
        lineage of target clade
        (optional) enter a different clade
        dictionary of species and lineages in target clade (species_dict)

Step 3: BLAST Parameters
    Inputs:
        BLAST e-value threshold
        maximum number of hits to return
    Outputs:
        temporary XML file of raw BLAST results
        number of hits

Step 4: Extracting data from BLAST search
    prune to one hit per species
    Outputs:
        dictionary of species, with e-value and accession numbers of hits (blast_dict)

Step 5: Taxonomic Search
    • for each species in taget clade, search protein list
    • if present, note this and record e-value & accession number
    • if not, note this
    Outputs:
        table of homologs in target clade
            <Species; Present (Y=Accession/N); E-Value; Lineage>

Step 6: Generate Taxonomic Tree
    Outputs:  
        tree file (Newick format)
"""

# MODULES

# standard Python modules
import os
import re
import sys
import math
import string
import datetime

# Biopython modules
from Bio import SeqIO
from Bio import Entrez
from Bio import SearchIO
from Bio.Seq import Seq
from Bio.Blast import NCBIWWW
from Bio.SeqRecord import SeqRecord

# modules with specialized functions
from treemaker import TreeMaker
import numpy as np
import pandas as pd

# HELP SYSTEM TOPICS

help_dict = {
    "license": "Copyright 2022 by Michael J. Gray. This work is licensed under the GNU GPLv3 License. To view a copy of this license, visit choosealicense.com/licenses/gpl-3.0/",
    "contact": "You can contact the author of this software at mjgray@uab.edu.",
    "tech support": "Unfortunately, due to my time constraints, this software is available ‘as-is’ and I cannot promise any tech support or future updates. I hope it’s helpful, but it may need some tweaking, especially as the underlying tools get updated in the future.",
    "credits": "The taxon-o-tron was written with Python 3.10.7, Biopython 1.79, BLAST+ 2.10.0, and matplotlib 3.5.3.",
    "dependencies": "The taxon-o-tron requires Python 3 and the following Python modules: biopython 1.76 or greater and matplotlib 3.2.1 or greater, all available for installation with pip.",
    "tutorial": "A tutorial will eventually be available for download at https://github.com/graymicrolab/taxon-o-tron",
    "Entrez email": "NCBI requires a valid email address to make automated requests from their Entrez server.",
    "save path": "The taxon-o-tron will create folders containing your results in the folder defined in the settings file.",
    "protein name": "The taxon-o-tron will accept any text as the name of your protein of interest, and that name will be used to generate the names of the resulting output files, along with a datestamp in the format YEARMODY (e.g 20200408 for April 8, 2020).",
    "overwriting data": "If a folder with the name of your requested analysis already exists, the taxon-o-tron can overwrite it. It will give you the option to quit and change the name of that folder instead, though.",
    "sequence": "You can enter either a partial or a full-length protein sequence. The taxon-o-tron will use whatever sequence you enter for its BLAST search, but will return full-length protein sequences from GenBank for alignments. Spaces or tabs are fine, but linebreaks are not, so remove those.",
    "number of hits": "BLAST searches have a maximum number of hits they can return. You would like this number to be higher than the number of total hits at the initial e-value cutoff. 20000 is a pretty safe bet, but particularly common proteins might return more hits than this.",
    "e-value cutoff": "Sets the stringency of the homology search. The hits vs. e-value graph generated by BLASTer is intended to give you the information you need to pick this.",
    "repeat step": "For several steps of the workflow, the taxon-o-tron gives the option to repeat the previous step with changed parameters, in case you’re not happy with the outcome.",
    "trimming": "The taxon-o-tron will report the length distribution of your BLAST results and give you the option to eliminate short or long sequences (or both), or to keep only long or short sequences.",
     }

# FUNCTIONS

def helper(topic):
    """ Refers to help_dict for appropriate info, then allows user to check other topics, too. """
    print("\n-------------------------------------------\n")
    print("Taxon-o-tron Contextual Help System\n")
    answer = help_dict.get(topic, "That topic has not been implemented. Oops!")
    print(answer + "\n")

    topic_list = list(help_dict.keys())
    topics_string = ", ".join(topic_list)

    asking = True
    while asking:
        choice = input("Available help topics (or ‘X’ to exit back to the main program):\n" + topics_string + "\n")
        if choice.upper() == "X" or choice.upper() == "EXIT" or choice.upper() == "":
            print("-------------------------------------------\n")
            asking = False
            return True
        elif choice.upper() == "Q" or choice.upper() == "QUIT":
            sys.exit()

        answer = help_dict.get(choice, "Please select one of the listed topics.")
        print("\n" + answer + "\n")

def is_email(test):
    """ Checks a string to see if it looks like it might be an email address. """
    result = re.findall('\S+@\S+', test) # regular expression for any text flanking an "@"
    if len(result) == 0:
        return False
    else:
        return True

def remove_extension(filename):
    """Given a file name, returns the file name without an extension."""        
    parts = filename.split(".")
    assert len(parts) == 2
    return parts[0]

def get_species(title):
    """From a GenBank identifier line, extracts the full species and strain name."""
    in_name = 0
    species = ""
    if "MULTISPECIES" in title:
        species = "MULTISPECIES CONSENSUS"
    else:
        for character in title:
            if character in "[]":
                in_name = in_name + 1
            elif in_name == 1:
                species = species + character
            elif in_name >= 2:
                break
    return species

def species_name(identifier):  
    """From the output of get_species, extracts the binomial species name.""" 
    breakdown = identifier.split()     
    if len(breakdown) <= 1:    
        return identifier
    elif breakdown[0] == "Candidatus":          
        name = breakdown[0] + " " + breakdown[1] + " " + breakdown[2]
        return name
    else:    
        name = breakdown[0] + " " + breakdown[1]      
        return name

def get_accession(hit_id):
    """Given a BLAST hit_id, returns the accession number."""        
    parts = hit_id.split("|")
    return parts[1]

# CODE

# get the current date and reformat it
today = datetime.date.today()
dateyear = str(today.year)
if len(str(today.day)) == 2:
    dateday = str(today.day)
else:
    dateday = "0" + str(today.day)
datemo = str(today.month)
if len(str(today.month)) == 2:
    datemo = str(today.month)
else:
    datemo = "0" + str(today.month)
datestamp = dateyear + datemo + dateday

# print introductory header
print("Taxon-o-tron version %s" % version)
print(updated)
print("A tool for examining the species-level taxonomic distribution of protein homologs. Best used in combination with BLASTer.py.")
print("by Michael J. Gray, M.S., Ph.D.\n")

# determine whether settings file exists
try:
    settings_handle = open("taxon-o-tron_settings.txt", "r")
    
# if it doesn't, collect the necessary information
except: 
    print("No settings file has been created. You will need to enter")
    
    asking = True    
    while asking:
        email = input("1. a valid email address (required by NCBI): ")
        if email.upper() == "Q" or email.upper() == "QUIT":
            sys.exit()
        elif email.upper() == "H" or email.upper() == "HELP":
            helper("Entrez email")
            continue
        elif is_email(email) == False:
            print("This is not an email address.") # a quick, dumb test, but better than nothing
            sys.exit()
        else:
            asking == False
            break
              
    asking = True
    while asking:
        basic_save_path = input("2. the path to the folder you want to save your data in: ")
        if basic_save_path.upper() == "Q" or basic_save_path.upper() == "QUIT":
            sys.exit()
        elif basic_save_path.upper() == "H" or basic_save_path.upper() == "HELP":
            helper("save path")
            continue
        elif os.path.exists(basic_save_path) == False: # checks to see if this is an existing directory
            print("No such directory exists.")
            sys.exit()
        else:
            asking == False
            break

    # write a new settings file
    outfile = open("taxon-o-tron_settings.txt", "w")
    
    email_line = "email:" + email + "\n"
    save_line = "basic_save_path:" + basic_save_path + "\n"
    
    outfile.write(email_line)
    outfile.write(save_line)

    outfile.close()

    print("\nFile created: taxon-o-tron_settings.txt\n")

    settings_handle = open("taxon-o-tron_settings.txt", "r")

# parse the settings file and tell the user what's in it

for line in settings_handle:
    line = line.rstrip() # get rid of the newline character
    separated = line.split(":") # break apart the line
    if separated[0] == "email":
        print("Entrez email = " + separated[1])
        Entrez.email = separated[1]
    elif separated[0] == "basic_save_path":
        print("Output file directory = " + separated[1]) 
        basic_save_path = separated[1]
    else:
        print("Malformed settings file.") # this should never happen
        sys.exit()

# print helpful information and a separator to indicate that the actual program is starting

print("\nAt any prompt, enter 'Q' to quit or 'H' for contextual help.")
print("------------------------------------------------------------")

# clearly define where we are in the workflow and allow escape from nested loops
step = 1

while True:

# Step 1: Collect Initial Inputs
#   inputs =
#       gene name = "name"
#       gene sequence = "input_record"

    while step == 1:

    # request the gene name
        asking = True
        while asking:
            name = input("Enter the protein name: ")
            if name.upper() == "Q" or name.upper() == "QUIT":
                sys.exit()
            elif name.upper() == "H" or name.upper() == "HELP":
                helper("protein name")
                continue
            else:
                asking = False

    # create a subdirectory to save the data in (and check to see if it already exists
        save_path = basic_save_path + "/" + datestamp + "taxon_" + name + "/"
        try:
            os.makedirs(save_path)
        except OSError:
            asking = True
            while asking == True:
                question = input("A data file already exists. Do you want to overwrite it? Y or N: ")
                if question.upper() == "N" or question.upper() == "NO":
                    print("Please move or rename the existing file.")
                    sys.exit()
                elif question.upper() == "Y" or question.upper() == "YES":
                    asking = False
                    pass
                elif question.upper() == "Q" or question.upper() == "QUIT":
                    sys.exit()
                elif question.upper() == "H" or question.upper() == "HELP":
                    helper("overwriting data")
                    continue
                else:
                    continue

    # request the protein input sequence
        asking = True
        while asking:
            seq = input("Enter the full or partial protein sequence (with no linebreaks): ")
                # can't figure out how to get it to accept input with linebreaks, which worked with Python 2
            useq = seq.strip().replace(" ","").upper() # remove whitespace
            if useq == "Q" or useq == "QUIT":
                sys.exit()
            elif useq == "H" or useq == "HELP":
                helper("sequence")
                continue
            else:
                asking = False
                continue

    # convert the input sequence into a Biopython SeqRecord            
        input_seq = Seq(useq)
        input_record = SeqRecord(input_seq, id=name, name=name, description="input sequence for BLAST search")

    # advance to the next step
        step = step + 1

# Step 2: Identify Target Clade
#   inputs =
#       target clade = "target_clade"
#   outputs:
#       is this a legitimate clade?
#       if so:
#           lineage
#           number of species in this clade
#       if not:
#           report error
#       confirm clade choice & allow repeat
#       dictionary of species in target clade, with their lineages

    while step == 2:

    # request the target clade (and capitalize the first letter of the input)
        asking = True
        while asking:
            target_clade_raw = input("\nEnter the clade of interest: ")
            target_clade = target_clade_raw.capitalize()
            if target_clade.upper() == "Q" or target_clade.upper() == "QUIT":
                sys.exit()
            elif target_clade.upper() == "H" or target_clade.upper() == "HELP":
                helper("target clade")
                continue

    # test whether this is a legitimate taxonomic group
            else:
                search_term = target_clade + "[SBTR] AND species[RANK] AND specified[PROP]"
                handle = Entrez.esearch(db="taxonomy", term=search_term, usehistory="y")
                record = Entrez.read(handle)
                try:
                    taxon_count = int(record["Count"])
                except:
                    taxon_count = 0

                if taxon_count == 0:
                    print("This is not a valid taxonomic group.")
                    continue

    # report useful information about the group            
                else:
                    print("\n"+ target_clade + " contains " + str(taxon_count) + " species. Lineage of example species: \n")
                    
                    try:
                        tax_id = record["IdList"][0]
                    except:
                        tax_id = "Not available"
                            
                    if tax_id != "Not available":
                        handle2 = Entrez.efetch(db="taxonomy", id=tax_id)
                        record2 = Entrez.read(handle2)
                        try:
                            taxon = record2[0]["Lineage"]
                        except:
                            taxon = "Sample lineage not available"
                    else:
                        taxon = "Sample lineage not available."

                    print(taxon + "\n")

    # confirm taxon choice
            checking = True
            while checking:
                clarify = input("Do you want to continue with this taxon? Y or N: ")            
                if clarify.upper() == "Q" or clarify.upper() == "QUIT":
                    sys.exit()
                elif clarify.upper() == "H" or clarify.upper() == "HELP":
                    helper("repeat step")
                    continue
                elif clarify.upper() == "Y" or clarify.upper() == "YES":
                    checking = False
                    asking = False
                    break
                elif clarify.upper() == "N" or clarify.upper() == "NO":
                    checking = False
                else:
                    continue

    # extract species list and make a dictionary with "ScientificName" as the key and "Lineage" as the value

        batch_size = 20
        species_dict = {}

        for start in range(0, taxon_count, batch_size):
            end = min(taxon_count, start + batch_size)
            print("Downloading records %i to %i" % (start + 1, end))
            fetch_handle = Entrez.efetch(
                db="taxonomy",
                retstart=start,
                retmax=batch_size,
                retmode="xml",
                webenv=record["WebEnv"],
                query_key=record["QueryKey"]
                )
            data = Entrez.read(fetch_handle)
            fetch_handle.close()
            for item in data:
                print(item["ScientificName"])
                species_dict[item["ScientificName"]]=item["Lineage"]

    # clean things up and advance to the next step
        handle.close()
        handle2.close()
        step = step + 1

# Step 3: BLAST Parameters
#   Inputs:
#       BLAST e-value threshold
#       maximum number of hits to return
#   Outputs:
#       temporary XML file of raw BLAST results

    while step == 3:
        
    # collect an e-value cutoff, and insist on an integer
        asking = True
        while asking: 
            try:
                cutoff = input("\nEnter an e-value cutoff (10^-X): ")
                if str(cutoff).upper() == "Q" or str(cutoff).upper() == "QUIT":
                    sys.exit()
                elif str(cutoff).upper() == "H" or str(cutoff).upper() == "HELP":
                    helper("e-value cutoff")
                    continue
                cutoff = int(cutoff) # in Python 3, input is always a string, and needs to be converted to a number
            except ValueError:
                print("Please enter an integer.")
                continue
            else:
                asking = False

    # set initial e-value cutoff (using input entered by user)
        e_thresh = math.pow(10, -int(cutoff))

    # collect an number of hits, and insist on a positive integer
        asking = True
        while asking: 
            try:
                hits = input("How many BLAST hits would you like you returned? (default = 20000) ")
                if str(hits).upper() == "Q" or str(hits).upper() == "QUIT":
                    sys.exit()
                elif str(hits).upper() == "H" or str(hits).upper() == "HELP":
                    helper("number of hits")
                    continue
                elif str(hits).upper() == "":
                    hits = 20000
                hits = int(hits) # in Python 3, input is always a string, and needs to be converted to a number
            except ValueError:
                print("Please enter an integer.")
                continue
            else:
                if int(hits) < 0:
                    print("Please enter a positive number")
                    continue
                asking = False

    # generate initial BLAST result
        print("\nRunning BLAST search (this may take a while)...\n")
        search_handle = NCBIWWW.qblast("blastp", "nr", input_record.seq, expect=e_thresh, hitlist_size=hits)

    # write a temporary XML file containing the results
        xmlfilename = name + ".xml"
        pathed_xmlfilename = os.path.join(save_path, xmlfilename)
        xml_file = open(pathed_xmlfilename, "w")
        xml_file.write(search_handle.read())
        xml_file.close()
        search_handle.close()

    # count the number of total hits
        hit_count = 0
        search_handle = open(pathed_xmlfilename, "r")
        blast_record = SearchIO.read(search_handle, "blast-xml")
        for hit in blast_record:
            hit_count = hit_count + 1
        print("Results: " + str(hit_count) + " hits.")

    # check to make sure this is OK
        if hit_count == int(hits):
            print("WARNING: number of BLAST hits requested is lower than available hits. Rerun with a more stringent e-value cutoff or a higher number of BLAST hits.")
            sys.exit()

    # advance to the next step
        step = step + 1

# Step 4: Extracting data from BLAST search
#   prune to one hit per species
#   Outputs:
#       dictionary of species, with accession numbers and e-values of hits

    while step == 4:
        blast_dict = {}
        species_counter = {}

    # get data from one hit per species and populate a dictionary with those data
        print("Extracting relevant data...")
        search_handle = open(pathed_xmlfilename, "r")
        blast_record = SearchIO.read(search_handle, "blast-xml")
        for hit in blast_record:
            for hsp in hit:
                ident = get_species(hsp.hit_description)         
                species = species_name(ident)
                if ident.isspace() == False: # eliminates poorly annotated or misformatted hits
                    if ident != "MULTISPECIES CONSENSUS" and ident != "":     
                        if species not in species_counter.keys():
                            species_counter[species] = 1
                            blast_dict[species]=[hsp.hit_id, hsp.evalue]
                        else:
                            if species_counter[species] < 1:
                                blast_dict[species]=[hsp.hit_id, hsp.evalue]
                                species_counter[species] = species_counter[species] + 1
                            else:
                                species_counter[species] = species_counter[species] + 1
        search_handle.close()

        # print("\nDictionary contents:\n")
        # for key, value in blast_dict.items():
        #     print(key, ": ", value)

    # get rid of the BLAST result file and advance to the next step
        os.remove(pathed_xmlfilename)
        step = step + 1

# Step 5: Taxonomic Search
#   • for each species in taget clade, search protein list
#   • if present, note this and record e-value & accession number
#   • if not, note this
#   Outputs:
#       table of homologs in target clade
#           <Species; Present (Y=Accession/N); E-Value; Lineage>

    while step == 5:

    # generate table header rows
        tablefile = name + "_taxon-o-tron_table.txt"
        pathed_tablefile = os.path.join(save_path, tablefile)
        save_file = open(pathed_tablefile, "w")
        first_row = name + " taxonomic conservation table, generated " + datestamp + " using taxon-o-tron.py version " + version + "\n"
        second_row = "Input sequence: " + useq + "\n"
        third_row = "Target Clade: " + target_clade + "\n"
        fourth_row = "E-Value Cutoff (10^-X): " + str(cutoff) + "\n"
        fifth_row = "Species\tHomolog\tE-Value\tLineage\n"
        save_file.write(first_row)
        save_file.write(second_row)
        save_file.write(third_row)
        save_file.write(fourth_row)
        save_file.write(fifth_row)

    # loop through target clade, comparing to BLAST results, and generating and saving new rows to table of species
        print("Generating results table...")

        for key, value in species_dict.items():
            if key in blast_dict:
                homol = get_accession(blast_dict[key][0])
                val = blast_dict[key][1]
            else:
                homol = "none detected"
                val = "N/A"

        # write the row of extracted data into the table
            row = str(key) + "\t" + str(homol) + "\t" + str(val) + "\t" + str(value) + "\n"
            save_file.write(row)

        print("Results table saved as " + tablefile + "\n")
        save_file.close()

    # advance to the next step
        step = step + 1

# Step 6: Generate Taxonomic Tree
#   Outputs:  
#       tree file

    while step == 6:
        print("Generating taxonomic tree...")

    # set root of tree and initialize it
        clean_target_clade = target_clade.translate(str.maketrans('', '', string.punctuation)).replace(" ", "_")
        newick_tree = TreeMaker()

    # open data file generated previously
        data_file = open(pathed_tablefile, "r")

    # loop to insert each species from the data file into the tree
        line_number = 0
        
        for line in data_file:
            line_number = line_number + 1
            if line_number >= 6:
                line_elements = line.rstrip().split("\t")
                
                # get species from line and remove whitespace
                line_species = line_elements[0].replace(" ", "_")
                
                # is there a homolog in this species?
                if line_elements[1] != "none detected":
                    line_species = line_species + "_+"
                    
                # get lineage from line and remove both whitespace and punctuation
                line_lineage = line_elements[3].split("; ")
                clean_lineage = []
                for item in line_lineage:
                    clean_item = item.translate(str.maketrans('', '', string.punctuation)).replace(" ", "_").replace("[","").replace("]","")
                    clean_lineage.append(clean_item)

                # remove elements of lineage upstream of the target clade
                for item in clean_lineage:
                    if item == clean_target_clade:
                        break
                    else:
                        clean_lineage.remove(item)

                # then turn it into a string with commas as separators
                if len(clean_lineage) > 1:
                    tree_input = ",".join(clean_lineage)
                elif len(clean_lineage) == 1:
                    tree_input = clean_lineage[0]
                else:
                    print("ERROR: clean_lineage list is empty")
                    sys.exit()

                # and add it to the tree
                newick_tree.add(line_species, tree_input)

    # write Newick formatted tree file
        newick_string = newick_tree.write()

        treefile = name + "_taxon-o-tron_tree.nwk"
        pathed_treefile = os.path.join(save_path, treefile)
        save_file = open(pathed_treefile, "w")
        save_file.write(newick_string)
        print("Newick tree file saved as " + treefile + "\n")
        save_file.close()
    
    # advance to the next step
        data_file.close()
        step = step + 1
        sys.exit()
